内容参考 [当···时发生了什么？](https://github.com/skyline75489/what-happens-when-zh_CN/blob/master/README.rst)，侵删

题目：当你在浏览器中输入google.com并且按下回车之后发生了什么？

**简单的答案**：

1. DNS查询
2. TCP连接
3. 客户端HTTP请求
4. 服务端HTTP响应
5. 客户端渲染

**比较全面的答案如下**：
# 1.按下"g"键 #
当你按下"g"键，浏览器接收到这个消息之后，会触发自动完成机制。浏览器根据自己的算法，以及你是否处于隐私浏览模式，会在浏览器的地址框下方给出输入建议。大部分算法会优先考虑根据你的搜索历史和书签等内容给出建议。你打算输入"google.com"，因此给出的建议并不匹配。但是输入过程中仍然有大量的代码在后台运行，你的每一次按键都会使得给出的建议更加准确。甚至有可能在你输入之前，浏览器就将"google.com"建议给你。

# 2.回车键按下 #
略（硬件及驱动的处理）
USB键盘：
xxx
虚拟键盘（触屏设备）：
xxx

# 3.产生中断【非USB键盘】 #
略（驱动以及操作系统处理）

# 4.(Windows)一个`WM_KEYDOWN`消息被发送往应用程序 #
# 4.(Mac OS X)一个`KeyDown` NSEvent被发往应用程序 #
# 4.(GNU/Linux)Xorg服务器监听键码值 #
# 5.解析URL #
- 浏览器通过URL能够知道下面的信息：
> `Protocol` "http":使用HTTP协议
> 
> `Resource` "/":请求的资源是主页(index)
# 6.输入的是URL还是搜索的关键字？ #
当协议或主机名不合法时，浏览器会将地址栏中输入的文字传给默认的搜索引擎。大部分情况下，在把文字传递给搜索引擎的时候，URL会带有特定的一串字符，用来告诉搜索引擎这次搜索来自这个特定浏览器。
# 7.转换非ASCII的Unicode字符 #
- 浏览器检查输入是否含有不是`a-z`,`A-Z`,`0-9`,`-`或者`.`的字符
- 这里主机名是`google.com`，所以没有非ASCII的字符；如果有的话，浏览器会对主机名部分使用Punycode编码
# 8.检查HSTS列表 #
- 浏览器检查自带的"预加载HSTS（HTTP严格传输安全）"列表，这个列表里包含了那些请求浏览器只使用HTTPS进行连接的网站
- 如果网站在这个列表里，浏览器会使用HTTPS而不是HTTP协议，否则，最初的请求会使用HTTP协议发送
- 注意，一个网站哪怕不在HSTS列表里，也可以要求浏览器对自己使用HSTS政策进行访问。浏览器向网站发出第一个HTTP请求之后，网站会返回浏览器一个响应，请求浏览器只使用HTTPS发送请求。然而，就是这第一个HTTP请求，却可能会是用户受到downgrade attack的威胁，这也是为什么现代浏览器都预置了HSTS列表。
# 9.DNS查询 #
- 浏览器检查域名是否在缓存当中（要查看Chrome当中的缓存，打开chrome://net-internals/#dns）。
- 如果缓存中没有，就去调用`gethostbyname`库函数（操作系统不同函数也不同）进行查询。
- `gethostbyname`函数在试图进行DNS解析之前首先检查域名是否在本地Hosts里，Hosts的位置**不同的操作系统有所不同**。
- 如果`gethostbyname`没有这个域名的缓存记录，也没有在`hosts`里找到，它将会向DNS服务器发送一条DNS查询请求。DNS服务器是由网络通信栈提供的，通常是本地路由器或者ISP的缓存DNS服务器。（ISP缓存，本身是一种宽带接入提供商给网页批量访问加速的技术。ISP会将当前访问量较大的网页内容放到ISP服务器的缓存中，当有新的用户请求相同内容时，可以直接从缓存中发送相关信息，不必每次都去访问真正的网站，从而加快了不同用户对相同内容的访问速度，同时也能节省网间流量结算成本呢。）
- 查询本地DNS服务器
- 如果DNS服务器和我们的主机在同一个子网内，系统会按照下面的ARP过程对DNS服务器进行ARP查询
- 如果DNS服务器和我们的主机在不同的子网，系统会按照下面的ARP过程对默认网关进行查询
# 10.ARP过程 #
要想发送ARP（地址解析协议）广播，我们需要有一个目标IP地址，同时还需要知道用于发送ARP广播的接口的MAC地址。

IP地址并不能代替物理地址，它只是在逻辑上表示一台主机，物理地址才对应于网卡的接口，只有找到它才能把数据送达到目的地。ARP负责把IP地址映射到物理地址。

- 首先查询ARP缓存，如果缓存命中，我们返回结果：目标IP = MAC

如果缓存没有命中：

- 查看路由表，看看目标IP地址是不是在本地路由表中的某个子网内。是的话，使用跟那个子网相连的接口，否则使用与默认网关相连的接口。
- 查询选择的网络接口的MAC地址
- 发送一个二层（OSI模型中的数据链路层）ARP请求：

`ARP Request`:

    Sender MAC: interface:mac:address:here
	Sender IP: interface.ip.goes.here
	Target MAC: FF:FF:FF:FF:FF:FF (Broadcast)
	Target IP: target.ip.goes.here

根据连接主机和路由器的硬件类型不同，可以分为以下几种情况：

直连：

- 如果我们和路由器是直接连接的，路由器会返回一个`ARP Reply`（见下面）。

集线器：

- 如果我们连接到一个集线器，集线器会把ARP请求向所有其它端口广播，如果路由器也”连接“在其中，它会返回一个`ARP Reply`。

交换机：

- 如果我们连接到了一个交换机，交换机会检查本地CAM/MAC表，看看哪个端口有我们要找的那个MAC地址，如果没有找到，交换机会向所有其它端口广播这个ARP请求。
- 如果交换机的MAC/CAM表中有对应的条目，交换机会向有我们想要查询的MAC地址的哪个端口发送ARP请求
- 如果路由器也”连接“在其中，它会返回一个`ARP Reply`

`ARP Reply`:

    Sender MAC: target:mac:address:here
	Sender IP: target.ip.goes.here
	Target MAC: interface:mac:address:here
	Target IP: interface.ip.gose.here

现在我们有了DNS服务器或者默认网关的IP地址，我们可以继续DNS请求了：

- 使用53端口向DNS服务器发送UDP请求包，如果响应包太大，会使用TCP协议
- 如果本地/ISP DNS服务器没有找到结果，它会发送一个递归查询请求，一层一层向高层DNS服务器做查询，直到查询到起始授权机构，如果找到会把结果返回

# 11.使用套接字 #
当浏览器得到了目标服务器的IP地址，以及URL中给出来端口号(http协议默认端口号是80，https默认端口号是443），它会调用系统库函数`socket`，请求一个TCP流套接字，对应的参数是`AF_INET/AF_INET6`和`SOCK_STREAM`。

- 这个请求首先被交给传输层，在传输层请求被封装成TCP segment。目标端口会被加入头部，源端口会在系统内核的动态端口范围内选取（Linux下是ip_local_port_range）
- TCP segment被送往网络层，网络层会在其中再加入一个IP头部，里面包含了目标服务器的IP地址以及本地的IP地址，把它封装成一个IP packet。
- 这个TCP packet接下来会进入链路层，链路层在封包中加入frame头部，里面包含了本地内置网卡的MAC地址以及网关（本地路由器）的MAC地址。像前面说的一样，如果内核不知道网关的MAC地址，它必须进行ARP广播来查询其地址。

到了现在，TCP封包已经准备好了，可以使用下面的方式进行传输：

- `以太网`
- `WiFi`
- `蜂窝数据网络`

对于大部分家庭网络和小型企业网络来说，封包会从本地计算机出发，经过本地网络，再通过调制解调器把数字信号转换成模拟信号，使其适用在电话线路，有线电视光缆和无线电话线路上传输。在传输线路的另一端，是另外一个调制解调器，它把模拟信号转换回数字信号，交由下一个`网络节点`处理。节点的目标地址和源地址将在后面讨论。

大型企业和比较新的住宅通常使用光纤或直接以太网连接，这种情况下信号一直是数字的，它回直接传到下一个`网络节点`进行处理。

最终封包会到达管理本地子网的路由器。在哪里出发，它会继续经过自治区域（autonomous system，缩写AS）的边界路由器，其他自治区域，最终到达目标服务器。一路上经过的这些路由器会从IP数据报头部里提取出目标地址，并将封包正确地路由到下一个目的地。IP数据报头部time to live（TTL）域的值每经过一个路由器就减一，如果封包的TTL变为0，或者路由器由于网络拥堵等原因封包队列满了，那么这个包会被路由器丢弃。

上面的发送和接收过程在TCP连接期间会发生很多次：

- 客户端选择一个初始序列号（ISN），将设置了SYN位的封包发送给服务器端，表明自己要建立连接并设置了初始序列号
- **服务端接收到SYN包，如果它可以建立连接**：
	- 服务器端选择它自己的初始序列号
	- 服务器端设置SYN位，表明自己选择了一个初始序列号
	- 服务器端把（客户端ISN+1)复制到ACK域，并且设置ACK位，表明自己接收到了客户端的第一个封包
- **客户端通过发送下面一个封包来确认这次连接**：
	- 自己的序列号+1
	- 接收端ACK+1
	- 设置ACK位
- **数据通过下面的方式传输**：
	- 当一方发送了N个Bytes的数据之后，将自己的SEQ序列号也增加N
	- 另一方确认接收到这个数据包（或者一系列数据包）之后，它发送一个ACK包，ACK的值设置为接收到的数据包的最后一个序列号
- **关闭连接时**：
	- 要关闭连接的一方发送一个FIN包
	- 另一方确认这个FIN包，并且发送自己的FIN包
	- 要关闭的一方使用ACK包来确认接收到了FIN
# 12.TLS握手 #
- 客户端发送一个`ClientHello`消息到服务器端，消息中同时包含了它的Transport Layer Security（TLS）版本，可用的加密算法和压缩算法。
- 服务器端向客户端返回一个`ServerHello`消息，消息中包含了服务端的TLS版本，服务器所选择的加密和压缩算法，以及数字证书认证机构（Cerificate Authority，缩写CA）签发的服务器公开证书，证书中包含了公钥。客户端会使用这个公钥教秘接下来的握手过程，直到协商产生一个新的对称密钥
- 客户端根据自己的信任CA列表，验证服务器端的证书是否可信。如果认为可信，客户端会生成一串伪随机数，使用服务器的公钥加密它。这串随机数会被用于生成新的对称密钥
- 服务器端使用自己的私钥解密上面提到的随机数，然后使用这串随机数生成自己的对称主密钥
- 客户端发送一个`Finished`消息给服务器端，使用对称密钥加密这次通讯的一个散列值
- 服务器端生成自己的hash值，然后解密客户端发送来的信息，检查这两个值是否对应。如果对应，就向客户端发送一个`Finished`消息，也使用协商好的堆成密钥加密
- 从现在开始，接下来整个TLS会话都使用对称密钥进行加密，传输应用层（HTTP）内容
# 13.HTTP协议 #
如果浏览器是Google出品的，它不会使用HTTP协议来获取页面信息，而是会与服务器端发送请求，商讨使用SPDY协议。

如果浏览器使用HTTP协议而不支持SPDY协议，它会向服务器发送这样的一个请求：

    GET / HTTP/1.1
	Host: google.com
	Connection: close
	[其他头部]

”其他头部“包含了一系列的由冒号分割开的键值对，它们的格式符合HTTP协议标准，它们之间由一个换行符分割开来。（这里我们假设浏览器没有违反HTTP协议标准的bug，同时假设浏览器使用`HTTP/1.1`协议，不然的话头部可能不包含`Host`字段，同时`GET`请求中的版本号会变成`HTTP/1.0`或者`HTTP/0.9`。）

HTTP/1.1定义了”关闭连接“的选项”close“，发送者使用这个选项指示这次连接在响应结束之后会断开。例如：
> Connection:close

不支持持久连接的HTTP/1.1应用必须在每条消息中都包含”close“选项。

在发送完这些请求和头部之后，浏览器发送一个换行符，标识要发送的内容已经结束了。

服务器端返回一个响应码，值是这次请求的状态，响应的形式是这样的：

    200 OK
	[响应头部]

然后是一个换行，接下来有效载荷（payload），也就是`www.google.com`的HTML内容。服务器下面可能会关闭连接，如果客户端请求保持连接的话，服务器端会保持连接打开，以供之后的请求重用。

如果浏览器发送的HTTP头部包含了足够多的信息（例如包含了Etag头部），以至于服务器可以判断出，浏览器缓存的文件版本自从上次获取之后没有再更改过，服务器可能会返回这样的响应：

    304 Not Modified
	[响应头部]

这个响应没有有效载荷，浏览器会从自己的缓存中取出想要的内容。

再解析完HTML之后，浏览器和客户端会重复上面的过程，直到HTML页面引入的所有资源（图片，CSS，favicon.ico等等）全部都获取完毕，区别值是头部的`GET / HTTP/1.1`会变成`GET /$(相对www.google.com的URL) HTTP/1.1`。

如果HTML引入了`www.google.com`域名之外的资源，浏览器会回到上面解析域名的那一步，按照下面的步骤往下一步一步执行，请求中的`Host`头部会变成另外的域名。

# 14.HTTP服务器请求处理 #
HTTPD（HTTP Daemon）在服务器端处理请求/响应。最常见的HTTPD有Linux常用的Apache和nginx，以及Windows上的IIS。

- HTTPD接收请求
- **服务器把请求拆分位以下几个参数**：
	- HTTP请求方法（`GET`, `POST`, `HEAD`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS` 或者 `TRACE`）。直接在地址栏中输入URL这种情况下，使用的是GET方法
	- 域名：google.com
	- 请求路径/页面： /（我们没有请求google.com下的指定的页面，因此/是默认的路径）
- 服务器验证其上已经配置了google.com的虚拟主机
- 服务器验证google.com接受GET方法
- 服务器验证该用户可以使用GET方法（根据IP地址，身份信息等）
- 如果服务器安装了URL重写模块（例如Apache的mod_rewrite和IIS的URL Rewrite），服务器会尝试匹配重写规则，如果匹配上的话，服务器会按照规则冲洗这个请求
- 服务器根据请求信息获取响应的响应内容，这个情况下由于访问路径是”/“，会访问首页文件（你可以重写这个规则，但是这个是最常用的）。
- 服务器会使用制定的处理程序分析处理这个文件，例如Google使用PHP，服务器会使用PHP解析index文件，并捕获输出，把PHP的输出结果返回给请求者

# 15.浏览器背后的故事 #
当服务器提供了资源之后（HTML,CSS,JS,图片等），浏览器会执行下面的操作：

1. 处理HTML标记并构建DOM树
2. 处理CSS标记并构建CSSOM树
3. 将DOM与CSSOM合并成一个渲染树
4. 根据渲染树来布局，以计算每个节点的几何信息
5. 将各个节点绘制到屏幕上

# 16.浏览器 #
浏览器的功能是从服务器上取回你想要的资源，然后展示在浏览器窗口当中。资源通常是HTML文件，也可能是PDF,图片或者其他类型的内容。资源的位置通过用户提供的URI(Uniform Resource Identifier)来确定。

浏览器解释和展示HTML文件的方法，在HTML和CSS标准中有详细介绍。这些标准由Web标准组织W3C(World Wide Web Consortium)维护。

不同浏览器的用户界面大都十分接近，由很多共同的UI元素：

- 一个地址栏
- 后退和前进按钮
- 书签选项
- 刷新和停止按钮
- 主页按钮

## 浏览器高层架构 ##
组成浏览器的组件有：

- **用户界面** 用户界面包含了地址栏，前进后退按钮，书签菜单等等，除了请求页面之外所有你看到的内容都是用户界面的一部分
- **浏览器引擎** 浏览器引擎负责让UI和渲染引擎协调工作
- **渲染引擎** 渲染引擎负责展示请求内容。如果请求的内容是HTML，渲染引擎会解析HTML和CSS，然后将内容展示在屏幕上
- **网络组件** 网络组件负责网络调用，例如HTTP请求等，使用一个平台无关接口，下层是针对不同平台的具体实现
- **UI后端** UI后端用于绘制基本UI组件，例如下拉列表框和窗口。UI后端暴露一个统一的平台无关的接口，下层使用操作系统的UI方法实现
- **Javascript引擎** Javascript引擎用于解析和执行Javascript代码
- **数据存储** 数据存储组件是一个持久层。浏览器可能需要在本地存储各种各样的数据，例如Cookie等。浏览器也需要支持诸如localStorage, IndexedDB, WebSQL和FileSystem之类的存储机制

# 17.HTML解析 #
浏览器渲染引擎从网络层取得请求的文档，一般情况下文档会分为8kB大小的分块传输。

HTML解析器的主要工作是对HTML文档进行解析，生成解析树。

解析树是以DOM元素以及属性为节点的树。DOM是文档对象模型（Document Object Model）的缩写，它是HTML文档的对象表示，同时也是HTML元素面向外部（如Javascript）的接口。树的根部是”Document“对象。整个DOM和HTML文档几乎是一对一的关系。

## 解析算法 ##
HTML不能使用常见的自顶向下或自底向上方法来进行分析，主要原因有以下几点：

- 语言本身的”宽容“特性
- HTML本身可能是残缺的，对于常见的残缺，浏览器需要有传统的容错机制来支持它们
- 解析过程需要反复。对于其他语言来说，源码不会再解析过程中发生变化，但是对于HTML来说，动态代码，例如脚本元素中包含的document.write()方法会在源码中添加内容，也就是说，解析过程实际上会改变输入的内容

由于不能使用常见的解析技术，浏览器创造了专门用于解析HTML的解析器。解析算法在HTML5标准规范中有详细的介绍，算法主要包含了两个阶段：标记化（tokenization）和树的构建。

## 解析结束之后 ##
浏览器开始加载网页的外部资源（CSS,图像,Javascript文件等）。

此时浏览器把文档标记为可交互的（interactive），浏览器开始解析处于”推迟（deferred）“模式的脚本，也就是那些需要在文档解析完毕之后再执行的脚本。之后文档的状态会变为”完成（complete）“，浏览器会触发”加载（load）“事件。

注意解析HTML网页时永远不会出现”无效语法（Invalid Syntax）“错误，浏览器会修复所有错误内容，然后继续解析。

# 18.CSS解析 #
- 根据**CSS词法和句法**分析CSS文件和`<style>`标签包含的内容以及style属性的值
- 每个CSS文件都被解析成一个样式表对象（`StyleSheet object`），这个对象里包含了带有选择器的CSS规则和对应CSS语法的对象
- CSS解析器可能是自顶向下的，也可能是使用解析器生成器生成的自底向上的解析器

# 19.页面渲染 #
- 通过遍历DOM节点树创建一个”Frame树“或”渲染树“，并计算每个节点的各个CSS样式值
- 通过累加子节点的宽度，该节点的水平内边距（padding）、边框（border）和外边距（margin），自底向上地计算”Frame树“中每个节点的首选(preferred)宽度
- 通过自顶向下地给每个节点地子节点分配可行宽度，计算每个节点的实际宽度
- 通过应用文字折行、累加子节点的高度和此节点的内边距（padding）、边框（border）和外边距（margin），自底向上地计算每个节点地高度
- 使用上面地计算结构构建每个节点地坐标
- 当存在元素使用`floated`，位置有`absolutely`或`relatively`属性地时候，会有更多复杂的计算
- 创建layer（层）来表示页面中的哪些部分可以成组地被绘制，而不用被重新栅格化处理。每个帧对象都被分配给一个，页面上地每个层都被分配了纹理（？？）
- 每个层地帧对象都会被遍历，计算机执行绘图命令绘制各个层，此过程可能由CPU执行栅格化处理，或者直接通过D2D/SKiaGL在GPU上绘制
- 上面所有步骤都可能利用到最近一次页面渲染时计算出来地各个值，这样可以减少不少计算量
- 计算出各个层地最终位置，一组命令由Direct3D/OpenGL发出，GPU命令缓冲区清空，命令传至GPU并异步渲染，帧被送到Window Server。

# 20.GPU渲染 #
- 在渲染过程中，图形处理层可能使用通用用途的`CPU`，也可能使用图形处理器`GPU`
- 在使用`GPU`用于图形渲染时，图形驱动软件会把任务分成多个部分，这样可以充分利用`GPU`强大的并行计算能力，用于在渲染过程中进行大量的浮点计算。

# 21.Window Server #
# 22.后期渲染与用户引发的处理 #
渲染结束后，浏览器根据某些事件机制运行JavaScript代码（比如Google Doodle动画）或与用户交互（在搜索栏输入关键字获得搜索建议）。类似Flash和Java的插件也会运行，尽管Google主页里没有，这些脚本可以触发网络请求，也可能改变网页的内容和布局，产生又一轮渲染与绘制。