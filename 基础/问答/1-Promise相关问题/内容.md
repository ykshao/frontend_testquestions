内容来自于知乎文章[当面试官问你Promise的时候，他究竟想听到什么？](https://zhuanlan.zhihu.com/p/29235579)，侵删
# 关于Promise的问题一览 #
- 什么是Promise？
- 传统的回调式异步操作有什么缺点？(Promise是如何解决异步操作)
- Promise中的异步模式有哪些？有什么区别？
- 如果向Promise.all()和Promise.race()传递空数组，运行结果会有什么不同？
- 如何确保一个变量是可信任的Promise(Promise.resolve方法传入不同值的不同处理有哪些)
- Promise是如何捕获异常的？与传统的try/catch相比有什么优势？

解答如下：
> 什么是Promise？

下面的回答很像是在背概念，但是很精辟

所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件的结果。从语法上说，Promise是一个对象，从它可以获取异步操作的消息。Promise提供统一的API，各种异步操作都可以用同样的方法进行处理，让开发者不用在关注于时序和底层的结果。Promise的状态具有不受外界影响和不可逆两个特点。

> 传统的回调式异步操作有什么缺点？(Promise是如何解决异步操作)

传统的回调有五大信任问题：

----------
1. 调用回调过早
2. 调用回调过晚（或没有被调用）
3. 调用回调次数过少或过多
4. 未能传递所需的环境和参数
5. 吞掉可能出现的错误和异常

promise的解决办法：

----------
1. 调用回调过早
：  
对于Promise来说，即使是立即完成的Promise也无法被同步观察到，也就是说一个Promise调用then()的时候，即使这个Promise已经决议了，提供给then的回调也总会被异步调用

2. 调用回调过完（或没有被调用）
：  
对于一个Promise对象注册的每一个观察回调都市相对独立、互不干预的。而Promise对象调用resolve()和reject()时，每个注册的观察回调也都会被自动调度。所以这些观察回调的任意一个都无法影响或延误对其他回调的调用
。  
此外，关于回调未调用。正常情况下，没有任何东西可以阻止Promise向你通知它的决议，即使你的JavaScript代码报错了，也会通过异常回调来捕获到。如果Promise永远不被决议的话，Promise本身已提供了竞态的抽象机制来作为解决方案。

3. 调用回调次数过少或过多
：  
Promise的定义方式使得它只能被决议一次。即使代码中出现多次决议，这个Promise也会接受第一次决议，并会忽略掉其他任何后续调用。所以任何通过then()注册的回调只会被调用一次。

4. 未能传递所需的环境和参数
：  
凡是被决议的值都会传递到观察回调中，如果没有显示的决议值也会传递一个undefined给观察回调。需要注意的是，Promise只允许传一个决议值，其他值都会被默默忽略掉。

5. 吞掉可能出现的错误和异常
：  
如果在创建Promise时，存在JavaScript代码错误，会直接导致该Promise的拒绝决议，那么你可以通过reject()来捕获异常，代码中的任何异常都不会吞掉。


以上的回答十分的啰嗦，但是如果上面的五点你都能记住的话，你会了解很多关于Promise的细节问题，也会应对一些面试官的追问，如Promise的then()会不会被重复调用等。

> Promise中的异步模式有哪些？有什么区别？

好吧，这个问题可能会把面试者问懵......可以考虑另一种问法，或者直接进入下一个问题，说一说Promise.all()和Promise.race()的区别。因为ES6中的Promise中只有这两个模式all和race，其他的如first、any、last等都是其他Promise库提供的。

回到问题本身，Promise.all()和Promise.race()的区别

all会将传入的数组中的所有promise全部决议以后，将决议值以数组的形式传入到观察回调中，任何一个promise决议为拒绝，那么就会调用拒绝回调。

race会将传入的数组中的所有promise中第一个决议的决议值传递给观察回调，即使决议结果是拒绝。

> 如果向Promise.all()和Promise.race()传递空数组，运行结果会有什么不同？

all会立即决议，决议结果是fullfilled，值是undefined

race会永远都不决议，程序卡死......

> 如何确保一个变量是可信任的Promise(Promise.resolve方法传入不同值的不同处理有哪些)

可以通过Promise.resolve()方法对不确定的值进行Promise化，返回一个Promise对象。

如果是一个立即值，如一个普通变量，那么该Promise会立即决议为成功。

如果是一个Promise值，那么会将该Promise直接返回赋值给这个Promise，不会有额外开销。

如果是一个类Promise值，比如其中含有名称为then的成员变量，那么会将then展开形成一个新的Promise对象。

> Promise是如何捕获异常的？与传统的try/catch相比有什么优势？

传统的try/catch捕获异常方式是无法捕获异步的异常的，代码如下：

    try {
		setTimeout(function() {
			undefined();  // undefined不是一个方法，会抛出异常
		}， 500);
	} catch(err) {
		// 这里并不能捕获异常
		console.log(err);
	}
而对于Promise对象来说，构造Promise实例时的代码如果出错，则会被认为是一个拒绝的决议，并会向观察回调中传递异常信息。所以即使是一个异步的请求，Promise也是可以捕获异常的。此外，Promise还可以通过catch回调来捕获回调中的异常。

# 总结 #
Promise是一个不错的异步操作解决方案，他解决了传统的通过回调和事件来解决异步操作的诸多问题，如“竞争”，回调信任度低的问题。ES6中也提供了标准的Promise供大家使用。
